/**
 * In wireguard-java, there are two categories of traffic, each with two directions.
 * <h2>Interface traffic</h2>
 * <p>
 * Interface traffic is traffic that is sent to or received from the operating system's tun device.
 * Interface traffic can be in the form of any IP packet, and never contains any WireGuard-specific data.
 * </p>
 *
 * <h3>OS-bound interface traffic</h3>
 * <p>
 * OS-bound interface traffic is traffic that is IP traffic going from within the VPN network to
 * the operating system's tun device.  Usually, this comes from transport packets received from other peers.
 * </p>
 *
 * <h3>OS-originating interface traffic</h3>
 * <p>
 * OS-originating interface traffic is traffic that is IP traffic generated by the operating system
 * which has been routed to the tun device.  By default, there are no routing rules present when a tun device is created,
 * and it's up to the end user to decide this -- the simplest way is to set the default route of the machine to the tun device
 * (or IP of the tun device, if the OS doesn't support routing to devices), and then adding a manual route for the VPN network
 * through whichever gateway network traffic originally went through.
 * </p>
 * <br>
 * Here's an example of how to do this on Linux, assuming our router is at abcd::1 and our VPN peers are at abcd::2 and abcd::3:
 * <pre>
 *         $ ip route show default
 *         default via abcd::1 dev eth0 # the gateway through traffic is usually routed
 *         $ ip route del default
 *         $ ip route add default dev tun0 # send traffic to the tun device in absence of more specific rules
 *         # route traffic to the VPN peers through the gateway
 *         $ ip route add abcd::2/128 dev eth0 # route traffic to the VPN peers through the gateway
 *         $ ip route add abcd::3/128 dev eth0
 *     </pre>
 * <p>
 * When we replace the default route with a route to the tun device, all of the traffic that was previously routed through the gateway
 * now will go through our tun device.  This is a problem because this includes traffic to the VPN peers, which obviously shouldn't
 * go through the VPN (since that would be a loop).  So, we add a more specific route for the VPN peers through the gateway,
 * which will override the default route for traffic to the VPN peers.
 * Typically, home networks don't have multiple gateways, so the above is sufficient.
 * </p>
 *
 *
 * <h2>Peer traffic</h2>
 * <p>
 * The other category of traffic is peer traffic, which is traffic that is sent to or received from a peer.
 * This is how peers on the VPN network talk amongst themselves, and includes both handshake packets (which WireGuard uses to
 * periodically rekey the session) and transport packets (which contain encrypted IP packets).
 * </p>
 *
 * <p>
 * Any traffic routed into a tun device is, for each peer, encrypted and sent as a transport packet.
 * WireGuard does NOT include routing;  it acts as an ethernet switch, and will send all traffic routed to
 * the tun device to all peers -- and will send all traffic received from peers to the tun device*.
 * <p>
 * * This is not entirely true;  wireguard-java supports the AllowedIPs configuration clause, which is a primitive
 * way to filter traffic.  If a peer has an AllowedIPs clause, then wireguard-java will only accept traffic from that peer
 * if the traffic's destination IP address is in the AllowedIPs clause.
 * </p>
 *
 * <h3>Outbound peer traffic</h3>
 * <p>
 * Outbound peer traffic is traffic that is sent to a peer.  This includes both handshake packets and IP packets ('transport' packets) routed into
 * the VPN's tun device.
 * Outbound peer traffic is sent to the peer's IP address and port, which is obtained from the peer's endpoint.  If
 * the peer does not have an endpoint configured, the address from which the peer performed its last handshake is used. // TODO:  make this true
 * </p>
 *
 * <h3>Inbound peer traffic</h3>
 * <p>
 * Inbound peer traffic is traffic that is received from a peer.  This includes both handshake packets and transport packets.
 * Besides handshake initiation packets, the actual origin IP of inbound peer traffic doesn't matter -- transport packets
 * and initiation response packets always include a unique receiver index corresponding to the peer's session data, which
 * is then used to verify the packet's authenticity and decrypt it.
 * </p>
 */
@ParametersAreNonnullByDefault
package ax.xz.wireguard.device;

import javax.annotation.ParametersAreNonnullByDefault;